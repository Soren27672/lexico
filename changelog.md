# Changelog


### 10
- handleGuess() now detects if the puzzle has been completely solved, setting the property ```completed``` to true if there are no false values in ```revealed```


### 9
- Created function generateIncorrect() in Strikes.js that takes an object of guesses and returns a string representing the previously guessed incorrect letters


### 8
- Created function generateBlanks() in Blanks.js that takes an array of letters and a revealed array and returns a string of blanks and letters that reflects the provided word and the current correct guesses


### 7
- Added handleGuess() function to PuzzlePage which detects non-letter characters, correct guesses, and incorrect guesses before executing a desired piece of code
    - handleGuess() detects invalid characters by first checking that they are one character long, then by checking that they are not the same uppercase and lowercase, if both tests pass, the program moves on to detecting if the guess was correct or not
    - The program establishes a variable ```correct``` as false and then iterates thru the array of letters in the puzzle, checking if it matches the inputted guess, if so, it sets correct to true
    - After iteration, the program updates the puzzle object. If the guess was correct, it will add the guess to the guesses object at the guessed key with a value of true and also update the revealed array so that the index of the correct letters is set to true. If the guess was incorrect, it will update the guesses object at the guessed key with a value of false and set strikes to the number of false values in the guesses object using a function ```instancesOfValueInObject()```, which is fairly self-explanatory


### 6
- Fixed bug with calculateValue
    - reduce method previously had it's initial value set to the point value of the first letter, which resulted in inaccurate scores
    - initial value is now set to zero
- PuzzlePage's parent div has been given an onKeyDown event and is now automatically focused when the user opens the PuzzlePage
    - This is accomplished by accessing the real DOM element thru useRef and then calling the focus() method on it in a useEffect that runs when the component is first rendered

### 5
- Upon the initial render, App makes two fetch requests, one to retrieve the list of puzzles so that it can create the unusedArray, and a second to retrieve the gameData object
    - It is also desired to retrieve a puzzle upon initially rendering, but in order to retrieve a puzzle and prepare it for its client-side functionality, the program must wait until the gameData object is retrieved, because that is where data such as the value of each letter is stored, which is needed to store the value of the puzzle within the client-side puzzle object
    - (it is not ideal to store the value of the puzzle within the puzzle's object in the backend, because then, the client is no longer capable of manipulating its own game data to create special-case game modifications. It is the server's responsibility to provide puzzles, and it is the client's responsibility to run the game in any manner necessary)
    - This wait is achieved by creating an ```initialized``` state, which is an object that contains several processes as properties and a boolean of whether or not they have run as their values
    - When ```initialized``` is updated, a useEffect callback is run, detecting whether all properties of ```initialized``` are true before fetching the puzzle object
    - Now that the two preconditions have been run, the puzzle object can be properly filled with value data
- Introduced calculateValue(), which takes an array of letters, a base value and a coefficient that normalizes a letter's frequency value between 1 and 57 to the desired point variance between easy and hard puzzles (1-200), and returns the difficulty value of the provided array of letters
- The Value component now displays a puzzle's value


### 4
- Created skeleton for puzzle page which loads dummy components
- Created Thumbnail component which currently just displays the text "thum"


### 3
- Added state to hold an unusedIds array, which holds all ids that have not yet been used so that the app is able to generate a different puzzle on successive games
    - This state is initiated with an empty array, but upon the first render, a useEffect fires which replaces the empty array with an array of all puzzle ids
    - This is generated by mapping the fetched array of puzzles by their id values
- App now has a getPuzzle function, this fetches a puzzle object from the backend and then adds it to a client oriented puzzle object that is prepared to hold data about the user's progress in the puzzle


### 2
- Added a fetch to the backend within App.js, this uses an environmental variable and the useState hook, activating only on the initial render
    - This is how I will be calling for the first puzzle when a user arrives at the page

    
### 1
- Created components PuzzlePage, ShopPage, LeaderboardPage, Blanks, Value and Strikes
- Created basic client-side routes for puzzle, shop and leaderboard pages